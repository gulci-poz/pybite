tworzymy alias na py3 w ~/.bashrc
alias python=python3
jeśli mamy py 3.5.0, to dajemy
alias python=python3.4

alternatywnie z użyciem alternatives
http://linuxconfig.org/how-to-switch-between-python-versions-on-fedora-linux

aktualizacja pip i pip3
sudo pip install --upgrade pip
sudo pip3 install --upgrade pip

pip3 ma być głównym pipem pod poleceniem pip
pip -V

w razie problemów z uruchomieniem pip3
sudo dnf reinstall python3-pip

sudo pip install --upgrade ipython

==================================================

zainstalować virtualenvwrapper

which virtualenvwrapper.sh
touch
less

edytujemy ~/.bashrc

export WORKON_HOME=$HOME/projects/py_projects/virtualenvs
export PROJECT_HOME=$HOME/projects/py_projects/dj_projects
source /usr/bin/virtualenvwrapper.sh

ponowne uruchomienie konsoli

w pliku /usr/bin/virtualenvwrapper.sh trzeba poprawić linię (sudo)
VIRTUALENVWRAPPER_PYTHON="$(command \which python)"
na python3
inaczej będzie szukał pakietu virtualenvwrapper w pakietach py2
a ja mam zainstalowaną wirtualkę i wrapper za pomocą pip3

po instalacji py 3.5.0 wskazuje na niego python3
w virtualenvwrapper.sh trzeba dać python3.4 zamiast python3

za pierwszym razem skrypt tworzy wirtualki

mkvirtualenv kurs

pip install "django==1.8.6"
pip install "django>=1.7,<1.8"
pip search django
list pokazuje więcej niż freeze, freeze pokazuje tylko ponadstandardowe pakiety
deactivate

aktualizujemy:
django
setuptools
wheel

trzeba być w folderze projektów, zmienna PROJECT_HOME nie ma tu zastosowania
django-admin startproject biblio

manage.py zawiera więcej niż django-admin.py

tworzymy powiązanie virtualenv z projektem django
uruchomiona wirtualka będzie powiązana z bieżącym folderem
setvirtualenvproject

workon
workon kurs

Uwaga! Zastępuje plik!
pip freeze > requirements.txt
doinstalowałem w systemie: littlecms, openjpeg, libjpeg-devel
nic to nie dało
pip install pillow
pip install -r requirements.txt

trzeba żywcem przekopiować biblioteki:

cp -rf /usr/lib64/python3.4/site-packages/PIL/ ~/projects/py_projects/virtualenvs/kurs/lib64/python3.4/site-packages/

cp -rf /usr/lib64/python3.4/site-packages/Pillow-3.0.0-py3.4.egg-info/ ~/projects/py_projects/virtualenvs/kurs/lib64/python3.4/site-packages/

pip install django-configurations

może się przydać
dnf install -y python3-devel
uda się wtedy zainstalować python3-numpy i python3-scipy

==================================================

dodaje do .gitignore
git rm --cached .idea -r
git rm --cached __pycache__ -r

"be verbose"
git remote -v

list zdalnych repozytoriów
git remote

wyświetla gałęzie
git branch
dla każdego błędu nowa gałąź

przełączenie z utworzeniem nowej gałęzi
git checkout -b fix-1

przejście do gałęzi
git checkout master

wskazanie jak zrobić push w gałęzi, gdy push jeszcze nie był wykonany
zostanie utworzona nowa gałąź w zdalnym repo
git push --set-upstream origin fix-1
(działa też z pull)

master to jest kod produkcyjny, nie powinno się z niego korzystać
dev to gałąź developerska
fix robimy na gałęzi, na której wystąpił błąd
gałęzie są tworzone od aktywnej gałęzi

używamy git flow do ogarnięcia gałęzi
git flow init
przełączy nas od razu na gałąź develop

obie gałęzie będą miały taką samą zawartość
git merge fix-1

kasowanie gałęzi
git branch -d gałąź

git push --all

zgłaszanie własnych zmian w kodzie - mechanizm pull request przy forkach

https://www.atlassian.com/git/tutorials/

==================================================

w django mamy MTV - Model, Template, View
View wyciąga dane z Model i przygotowuje do wyświetlania w Template
Template jest odpowiednikiem MVC.View
View analizuje ścieżkę URL i poprzez View wyciąga Model

./manage.py migrate
./manage.py runserver (możemy to robić na screen)

jedna aplikacja - jedno zadanie; dużo małych aplikacji
./manage.py startapp

admin.py
konfiguracja panelu administratora, podłączenia modeli

migrations
zmiany modeli w bazie

models.py
definiujemy jak będą wyglądały obiekty w bazie danych

test.py
testy

views.py
realizacja części View

w py3 nie trzeba w ogóle informować o kodowaniu, wszystkie pliki są w UTF-8

po dodaniu modelu danych w models.py trzeba dodać aplikację shelf w settings.py (INSTALLED_APPS)
robimy schema migration, informacje o zmianie struktury bazy są przechowywane w plikach w folderze migrations
./manage.py makemigrations
migracji można nadać nazwę używając --name
sychronizacja bazy danych z obecnymi modelami i migracjami (anjpierw synchronizuje niezmigrowane aplikacje, robi to samo co syncdb, a potem przeprowadza migracje, które jeszcze nie zostały przeprowadzone)
./manage.py migrate

migracje danych robimy przygotowując pusty plik migracji (makemigrations) i po uzupełnieniu robimy migrację (migrate), synchronizacja danych zostanie wykonana automatycznie z sychronizacją bazy

jeśli mamy zmianę typu pola, to lepiej zrobić nowe pole z nowym typem niż dawać nowy typ do istniejącego pola (u nas np. zmiana author na authors); koniecznie jeśli mamy zmianę typów relacyjnych np. ForeignKey na ManyToManyField, mniej ważne przy zmianie danych numerycznych i tekstowych

./manage.py createsuperuser

rejestrujemy model w admin.py

mamy dostęp do shella django
./manage.py shell
django rozpoznaje, że jest ipython i automatycznie się do niego przełącza
możemy przeglądać modele (przyda się potem przy zapytaniach do db)
from shelf.models import Author
Author.objects.all()

django guardian - aplikacja do nadawania uprawnień do obiektów

dołączam model do widoku w views.py i zapisuję url do widoku w urls.py
szablony

przechodzi całe drzewo projektu i wyciąga stringi do translacji, tworzy lub uaktualnia plik message; trzeba samemu utworzyć folder locale
./manage.py makemessages -l pl
dostajemy plik .po (Portable Object)
jeśli tego nie zrobiliśmy po dodaniu funkcji _ (ugettext_lazy), to teraz trzeba
./manage.py makemigrations
./manage.py migrate
trzeba dodać LOCALE_PATH do settings.py
django-admin compilemessages
dostajemy plik .mo (top level locale)
plik binarny zoptymalizowany do użycia przez ugettext_lazy
aplikacje:poedit (sudo dnf install pootle)
pootle (napisany w django, działa w py2, wymaga import pootle)

użycie shell:
from shelf.models import Author, Book, BookItem, BookEdition, BookCategory, Publisher
Author.objects.all()
autor = Author()
autor.first_name = "Mario"
autor.last_name = "Vargas Llosa"
autor.save()
autor.id
(autor.pk)
#dopóki obiekt nie jest zapisany w bazie, to nie ma id; sposób na sprawdzenie obecności modelu (obiektu, nazywa go też modelem) w bazie
a = Author(first_name = "Juliusz", last_name = "Verne")
a.save()
a2 = Author.objects.create()
#stworzyliśmy obiekt, który został dodany do bazy, ale ma puste pola
a2.id
a2.first_name
#id pozostanie zajęte
a2.delete()
a2 = Author.objects.create(first_name = "Henryk", last_name = "Sienkiewicz")
#atrybut objects jest powiązany z managerem obiektów, sposób na dostanie się do bazy danych
#tutaj zostało wykonane zapytanie
Author.objects.all()
#tutaj nie
value = Author.objects.all()
type(value)
#dostajemy QuerySet, typ leniwy, pośrednik w dostępnie do bazy
#teraz dopiero poszło zapytanie do bazy
value.filter(last_name__contains = "wicz")
#dodawanie autorów do ManyToMany (jak zrobić w dj w panelu adm. szukanie search_fields po ManyToMany?)
ac1 = Author(first_name = "Brian", last_name = "Kernighan")
ac1.save()
ac2 = Author(first_name = "Dennis", last_name = "Ritchie")
ac2.save()
#nie możemy pod authors podstawić autora (obiektu), może uda się listę?
book = Book.objects.create(title = "Język C")
#tu mamy relację
book.authors
#tu się dowiadujemy, że mamy pustą listę
book.authors.all()
book.authors.add(ac1)
book.authors.add(ac2)
book.save()
#nowa sesja + import
b = Book.objects.all().last()
b
b.authors.all()
#->5.1.4.10
