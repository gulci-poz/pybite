tworzymy alias na py3 w ~/.bashrc
alias python=python3
jeśli mamy py 3.5.0, to dajemy
alias python=python3.4

alternatywnie z użyciem alternatives
http://linuxconfig.org/how-to-switch-between-python-versions-on-fedora-linux

aktualizacja pip i pip3
sudo pip install --upgrade pip
sudo pip3 install --upgrade pip

pip3 ma być głównym pipem pod poleceniem pip
pip -V

w razie problemów z uruchomieniem pip3
sudo dnf reinstall python3-pip

sudo pip install --upgrade ipython

==================================================

zainstalować virtualenvwrapper

which virtualenvwrapper.sh
touch
less

edytujemy ~/.bashrc

export WORKON_HOME=$HOME/projects/py_projects/virtualenvs
export PROJECT_HOME=$HOME/projects/py_projects/dj_projects
source /usr/bin/virtualenvwrapper.sh

ponowne uruchomienie konsoli

w pliku /usr/bin/virtualenvwrapper.sh trzeba poprawić linię (sudo)
VIRTUALENVWRAPPER_PYTHON="$(command \which python)"
na python3
inaczej będzie szukał pakietu virtualenvwrapper w pakietach py2
a ja mam zainstalowaną wirtualkę i wrapper za pomocą pip3

po instalacji py 3.5.0 wskazuje na niego python3
w virtualenvwrapper.sh trzeba dać python3.4 zamiast python3

za pierwszym razem skrypt tworzy wirtualki

mkvirtualenv kurs

pip install "django==1.8.6"
pip install "django>=1.7,<1.8"
pip search django
list pokazuje więcej niż freeze, freeze pokazuje tylko ponadstandardowe pakiety
deactivate

aktualizujemy:
django
setuptools
wheel

trzeba być w folderze projektów, zmienna PROJECT_HOME nie ma tu zastosowania
django-admin startproject biblio

manage.py zawiera więcej niż django-admin.py

tworzymy powiązanie virtualenv z projektem django
uruchomiona wirtualka będzie powiązana z bieżącym folderem
setvirtualenvproject

workon
workon kurs

Uwaga! Zastępuje plik!
pip freeze > requirements.txt
doinstalowałem w systemie: littlecms, openjpeg, libjpeg-devel
nic to nie dało
pip install pillow
pip install -r requirements.txt

trzeba żywcem przekopiować biblioteki:

cp -rf /usr/lib64/python3.4/site-packages/PIL/ ~/projects/py_projects/virtualenvs/kurs/lib64/python3.4/site-packages/

cp -rf /usr/lib64/python3.4/site-packages/Pillow-3.0.0-py3.4.egg-info/ ~/projects/py_projects/virtualenvs/kurs/lib64/python3.4/site-packages/

pip install django-configurations

może się przydać
dnf install -y python3-devel
uda się wtedy zainstalować python3-numpy i python3-scipy

==================================================

dodaje do .gitignore
git rm --cached .idea -r
git rm --cached __pycache__ -r

"be verbose"
git remote -v

list zdalnych repozytoriów
git remote

wyświetla gałęzie
git branch
dla każdego błędu nowa gałąź

przełączenie z utworzeniem nowej gałęzi
git checkout -b fix-1

przejście do gałęzi
git checkout master

wskazanie jak zrobić push w gałęzi, gdy push jeszcze nie był wykonany
zostanie utworzona nowa gałąź w zdalnym repo
git push --set-upstream origin fix-1
(działa też z pull)

master to jest kod produkcyjny, nie powinno się z niego korzystać
dev to gałąź developerska
fix robimy na gałęzi, na której wystąpił błąd
gałęzie są tworzone od aktywnej gałęzi

używamy git flow do ogarnięcia gałęzi
git flow init
przełączy nas od razu na gałąź develop

obie gałęzie będą miały taką samą zawartość
git merge fix-1

kasowanie gałęzi
git branch -d gałąź

git push --all

zgłaszanie własnych zmian w kodzie - mechanizm pull request przy forkach

https://www.atlassian.com/git/tutorials/

==================================================

w django mamy MTV - Model, Template, View
View wyciąga dane z Model i przygotowuje do wyświetlania w Template
Template jest odpowiednikiem MVC.View
View analizuje ścieżkę URL i poprzez View wyciąga Model

./manage.py migrate
./manage.py runserver (możemy to robić na screen)

jedna aplikacja - jedno zadanie; dużo małych aplikacji
./manage.py startapp

admin.py
konfiguracja panelu administratora, podłączenia modeli

migrations
zmiany modeli w bazie

models.py
definiujemy jak będą wyglądały obiekty w bazie danych

test.py
testy

views.py
realizacja części View

w py3 nie trzeba w ogóle informować o kodowaniu, wszystkie pliki są w UTF-8

po dodaniu modelu danych w models.py trzeba dodać aplikację shelf w settings.py (INSTALLED_APPS)
./manage.py makemigrations
trzeba też dać migrate, do bazy zostanie zaaplikowany model aplikacji
./manage.py migrate

./manage.py createsuperuser

rejestrujemy model w admin.py

mamy dostęp do shella django
./manage.py shell
django rozpoznaje, że jest ipython i automatycznie się do niego przełącza
możemy przeglądać modele (przyda się potem przy zapytaniach do db)
from shelf.models import Author
Author.objects.all()

django guardian - aplikacja do nadawania uprawnień do obiektów

dołączam model do widoku w views.py i zapisuję url do widoku w urls.py
szablony
